\chapter{Introduction}
\label{ch:introduction}
Increased competition and complexity of the problems companies are solving today is changing how software is developed. Software development is getting increasingly more focused towards having short and independent release cycles based on individual features rather than entire applications. Solving complex problems often yield a very complex and fragile solution, but the most successful tech companies have succeeded in utilizing a new architecture pattern: namely Microservices. By creating microservices, changing development process and team structure drastically, modern tech companies create innovative and resilient software quicker than ever before.

Several factors has made this new paradigm for developing big scale distributed applications possible. Cloud computing has made it possible to buy computing resources as they are needed, cheap and fast. Virtualization and lately containerization making it possible to create isolated environments, enabling partitioning of applications, into a subset of components that can be developed and deployed independently. Dynamic orchestration of containers, makes it possible to ensure correct capacity and redundancy of application components automatically. Segmentation of the applications in turn makes it possible to maintain a acceptable level of complexity of the source code improving maintainability and increasing agility.

\note {
A boom of knowledge sharing throughout the industry, through conference talks and a huge variety of high quality open source projects, together with new programming languages, makes it possible for independent development teams to go from development to deployment very quickly, while taking the complexity of the internet increasingly into account. This has created a new and competitive environment, where understanding and solving complex problems is a process that has to be repeated daily and quickly. Software developers now need to understand the domain and the context they are developing software for in a much higher degree than ever before. 
Having the best and most stable solution to a given problem is not necessarily enough, time to market is extremely important to capture market share as well. New applications need to be available to the customer immediately, and at all times, lack of new features and downtime is immediately visible on the company bottom line.
}

\section{Knowledge sharing}
A rising trend of knowledge sharing has started, where online accessible conference talks and a high quantity of open source projects inspire and help developers solve common challenges. Conferences have focus on new open source technology, system architecture, working process and organisational structure, all with a common goal: speeding up software development and the ability to solve increasingly difficult problems. Conferences are either entirely committed to or has tracks about topics like Cloud computing, Agile development, Domain Driven Design, Microservices, NoSQL, Docker, Cassandra among many others\cite{george2016it}. Company internal projects that prior was only internal accessible, are increasingly made open source, giving developers very advanced tools to create elegant and efficient solutions quickly. These projects are freely accessible, with well known support challenges, where developers can find help with specific challenges utilizing the projects. The Cloud Native Computer Foundation\footnote{\url{https://www.cncf.io/}} is a foundation based entirely on helping non-software focused companies become cloud native: utilizing the power of containerization, and dynamically orchestrated microservices.

The entire movement started when Amazon, an electronic commerce compnay know for their cloud computing solution, announced Amazon Web Services in 2006. It meant anyone could register and rent virtual machines for hosting distributed applications. Since then, virtualization has been further revolutionised with the introduction of container technology, which was made open source through the Docker initiative in 2014. Docker made it possible to start up new independent and isolated environments in seconds, something Google had developed on internally because they needed it \cite{bernstein2014containers}. Which is somewhat a trademark for the entirety of the cloud native movement, is has sprung out of a big variety of needs: serving massive amounts of users, creating reliable applications, the ability to update and add functionality often and easily, minimize integration complexity and technology lock in. In the end the focus should be on solving new problems and not on dealing with an forever growing monolithic application. Microservices have sprung out as a trend in real world use \cite[p.~1]{newman2015microservices}.

\section{Microservices}
Monolithic applications were a result of technological boundaries, and made developing good design a major challenge. These boundaries have disappeared, pushing developers towards more thoughtful design of applications. Developers today need to put emphasis on understanding the underlying challenges in the particular domain, identifying the optimal architecture that supports the context \cite[t.~17:00]{evans2016tackling}. High complexity and a strict time to market makes problem solving hard. It is therefore very important to optimize the entire process from identification of a correct solution, through development and deployment of the feature. There are three clear factors in this process: technology utilization, correct working process and organisational structure \cite[t.~12:16]{george2016it} \cite[preface]{newman2015microservices}. 

The amount of available languages, frameworks and tools has grown tremendously, making it possible to solve complex problems easier and quicker than before. Utilizing available technology is uttermost important to achieve the best solution for a given problem. Traditionally speaking organisations often divided people into departments according to their specific competences. Development project would therefore span several departments, creating a need for standardization of tools, languages and working processes. This inherently limits the amount of innovation possible, engineers are forced to solve all problems a predetermined way, resulting in similar solutions for very diverse problems \cite[t.~14:20]{fowler2014microservicesoamonolith} \cite[00:30]{kniberg2014spotify} \cite{murer2015fifteen} \cite[17:00]{meshenberg2016microservices}. 

The organisation structure's impact on software development has been broadly acknowledged \cite{fowler2014microservices, newman2014demystifying}, and companies are therefore breaking pre-existing organisational structures, prohibiting fast and agile development. Many tech companies have publicly talked about their innovative ways of working, that has allowed them to improve the amount of innovation and the productivity of their software engineers \cite[00:30]{kniberg2014spotify} \cite[16:00]{meshenberg2016microservices}. By having a strong focus on having small, strong, cross-functional and self-organising teams that have "end-to-end" responsibility for the features they build. Teams have an overall mission, knowledge of their specific product strategy and short-term goals that help keep the team on the wished path. Each team is given autonomy, responsible for finding the best way for the team to develop new features, which features the team should implement and how they work together. Everyone in the team is located in the same physical location, creating the optimal conditions for good collaboration across skill-sets \cite[01:00]{kniberg2014spotify} \cite{gray2006conversation}.

\begin{figure}[!htb]
  \begin{center} 
	  \includegraphics[scale=0.27]{introduction_squads}  
  \end{center}
  \caption{Spotify team structure}
  \label{fig:introduction_squads}
\end{figure}

This is a completely new way of designing an organisation, and removes pre-existing process and organisation inhibitors. It is possible for each team to create and release features independently, minimizing waiting time between teams. At the same time teams are responsible for what they create, removing handoffs between teams. The focus is having loosely coupled but tightly aligned teams.
It is important that organisation and process inhibitors are removed before utilizing microservices as an architecture choice \cite{meshenberg2016microservices}. This will make it possible to utilize available technology to the fullest, by allowing teams to choose which technology is used for development of the separate features \cite{fowler2014polyglot}. 


\section{Resilience}
The internet, and the services it makes available, has in recent years expanded in order of magnitude \cite[p.~4]{nygard2007release}, consequences of downtime are hard to estimate but can effect user satisfaction and trust, and loss of brand and reputation incurring direct and indirect bottom line losses \cite[p.~26]{beyer2016siteReliabilityEngineering}. The internet and the services it makes available are essential to modern life, making consequences of down time increasingly severe, it is generally acknowledged that services available over the internet are not suficiently resilient \cite{sterbenz2010resilience}. Designing systems with an increased scale and reach incurs a need for optimizing architecture so that it mitigates failure \cite[p.~4]{nygard2007release}, focus needs to be shifted to the incorporate the entire lifetime of the application, not only focusing on the development process:

\tquote{Software engineering has this in common with having children: the labor before the birth is painful and difficult, but the labor after the birth is where you actually spend most of your effort. Yet software engineering as a discipline spends much more time talking about the first period as opposed to the second, despite estimates that 40â€“90\% of the total costs of a system are incurred after birth}{Beyer et al.}{2016}

Due to rapid growth in scale and complexity, it is increasingly important to acknowledge that failure is bound to happen, and reducing the risk of failures and the effects is essential \cite{abid2014toward} \cite[p. 117]{nygard2007release} \cite{tseitlin2013antifragile} \cite{krishnan2012weathering}. Gone are the days where developers only focused on development and deployment, and maintenance of a system was distant processes in the hands of the operations team. The microservice community embraces ownership \textit{"You build it, you run it"} \cite{gray2006conversation} is the new mantra, embracing deployment and maintenance and focusing on how to make system more resilient when in production \cite[p.~6]{nygard2007release}. 

Consequently the stability patterns and their antipatterns have to be analysed (how is failure avoided and what enhances failure), how does the acknowledgement of failure translate into the implementation. Learning from previous efforts to improve resilience is paramount, utilizing the knowledge and the technology stack made available for free use. Gaining an insights into the microservice and cloud native communities is not easy, the problems these communities set out to solve are inherently very complex and it can be very time consuming to understanding which problems a given architectural pattern or open source technology tries to solves. So many different parties inform about the importance of resilience and how it can be achieved, but how are these patterns and technologies implemented in a modern software development department, with existing systems and a specific and complex domain? How are the effects of efforts on improving resilience in a system made quantifiable?

There is a clear gap between the available resources and a concrete implementation, it requires intricate knowledge of the infinite amount of available languages, frameworks and tools to evaluate which to use in a given situation. 
At the same time, who is there to help us if we do not understand the usage of a given open source project or a new update breaks some existing functionality that we were inherently dependent on working correctly? These aspects of open source does not ring well in big and established enterprise organisations. If so many different and respectable sources say that we need to design resilient software, well then there surely must be something about it, but how do we choose the proper solution between the many and how do we evaluate the impact?

\input{sections/introduction/problem_formulation.tex}

\section{The Solution}
By introducing the microservice architecture, development time, technology utilization and system resilience can be severely improved. The concerns in focus in the microservice community is threefold: implementation, process and organisation. By increasing the granularity of system subdivision, a higher regard to detail is attainable, making it possible to release often and fast, identify and solve problems quickly and correctly, and creating systems with a manageable complexity. The microservice architecture improves service availability by dictating small and independent services, with focus on individual features instead of entire products, decentralizing data management, automating infrastructure management and design services for resilience. Replication is made possible by isolating services into separate environments, improving capacity, introducing redundancy and thereby removing single point of failure. By designing applications with stability patterns and antipatterns in mind typical pitfalls known to cause failure are avoided. This thesis shows the effects of replication, by load testing a service with varying degree of replication, by replicating the service the availability was increase, improving response time and percentage of successful responses. This was possible due to the increased isolation of the service.

